
# ğŸ§  1. Introduction to MediatR and CQRS

### âœ… **CQRS**:

- Separates **read operations (queries)** from **write operations (commands)**.
    
- Encourages clearer architecture, testability, and scalability.
    

### âœ… **MediatR**:

- A **library** that enables the **Mediator Pattern**.
    
- It **decouples** request senders (controllers) from request handlers (business logic).
    
- Promotes **clean separation of concerns**, reducing coupling between layers.
    

---

# ğŸ§© 2. Core Interfaces of MediatR

### ğŸ”¹ `IRequest<TResponse>`

- Marker interface for a request that returns a response.
    
- All **commands and queries** implement this interface.
    

```csharp
public [[record]] GetUserByIdQuery(Guid Id) : IRequest<UserDto>;
```

---

### ğŸ”¹ `IRequestHandler<TRequest, TResponse>`

- Handles the request and returns the response.
    

```csharp
public class GetUserByIdHandler : IRequestHandler<GetUserByIdQuery, UserDto>
{
    public async Task<UserDto> Handle(GetUserByIdQuery request, CancellationToken ct)
    {
        // fetch user logic here
    }
}
```

---

### ğŸ”¹ `IMediator` (Full Interface)

- The **main interface** of MediatR. It includes:
    

```csharp
Task<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken ct = default);
```

- Used to **send** requests (commands/queries) to the appropriate handlers.
    
- Typically injected into **controllers or services**.
    

---

### ğŸ”¹ `ISender` (Simplified Interface)

- A **subset of `IMediator`** that only allows sending requests (`Send`), but not `Publish`.
    
- Use this for stricter **command/query only** responsibility.
    

---

### ğŸ”¹ `INotification`, `INotificationHandler<TNotification>` (Optional)

- For **event publishing** (not commands/queries). Follows pub-sub model.
    

---

# ğŸ”„ 3. Request Flow Using MediatR + CQRS

### ğŸ§­ Full Pipeline:

```
HTTP Request â†’ Controller â†’ MediatR.Send() â†’ Pipeline Behaviors (e.g., Logging, Validation) â†’ Handler â†’ Return Response
```

### Detailed Steps:

1. **Client** sends HTTP request (e.g., POST `/users`)
    
2. **Controller** receives request and calls `IMediator.Send(command)`
    
3. **MediatR** finds a matching `IRequestHandler<TRequest, TResponse>`
    
4. **Before** handler runs:
    
    - Pipeline behaviors execute in order (e.g., validation, logging, transactions)
        
5. **Handler** executes and returns result
    
6. **Controller** sends HTTP response
    

---

# âš™ï¸ 4. Pipeline Behaviors

`IPipelineBehavior<TRequest, TResponse>` is used to:

- Add **cross-cutting concerns** like:
    
    - Validation
        
    - Logging
        
    - Transaction handling
        
    - Authorization
        

### Example: Validation Behavior

```csharp
public class ValidationBehavior<TRequest, TResponse> : IPipelineBehavior<TRequest, TResponse>
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;

    public ValidationBehavior(IEnumerable<IValidator<TRequest>> validators)
        => _validators = validators;

    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken ct)
    {
        var context = new ValidationContext<TRequest>(request);
        var failures = _validators.Select(v => v.Validate(context))
                                  .SelectMany(r => r.Errors)
                                  .Where(f => f != null)
                                  .ToList();

        if (failures.Any())
            throw new ValidationException(failures);

        return await next(); // Continue to handler
    }
}
```

---

# ğŸ“¦ 5. Real-World Project Structure

```
/src
 â””â”€â”€ Application
     â”œâ”€â”€ Users
     â”‚    â”œâ”€â”€ Commands
     â”‚    â”‚    â”œâ”€â”€ CreateUserCommand.cs
     â”‚    â”‚    â””â”€â”€ CreateUserHandler.cs
     â”‚    â”œâ”€â”€ Queries
     â”‚    â”‚    â”œâ”€â”€ GetUserByIdQuery.cs
     â”‚    â”‚    â””â”€â”€ GetUserByIdHandler.cs
     â”‚    â””â”€â”€ Validators
     â”‚         â””â”€â”€ CreateUserCommandValidator.cs
     â”œâ”€â”€ Interfaces
     â”‚    â””â”€â”€ IAppDbContext.cs
     â””â”€â”€ Behaviors
          â”œâ”€â”€ ValidationBehavior.cs
          â””â”€â”€ LoggingBehavior.cs

 â””â”€â”€ Infrastructure
     â””â”€â”€ Persistence
         â”œâ”€â”€ AppDbContext.cs
         â””â”€â”€ Migrations/

 â””â”€â”€ API
     â””â”€â”€ Controllers
         â””â”€â”€ UsersController.cs

 â””â”€â”€ Domain
     â””â”€â”€ Entities
         â””â”€â”€ User.cs
```

---

# âœ… 6. Code Example with Best Practices

### 6.1 `CreateUserCommand.cs`

```csharp
public record CreateUserCommand(string Name, string Email) : IRequest<Guid>;
```

---

### 6.2 `CreateUserHandler.cs`

```csharp
public class CreateUserHandler : IRequestHandler<CreateUserCommand, Guid>
{
    private readonly IAppDbContext _context;

    public CreateUserHandler(IAppDbContext context)
        => _context = context;

    public async Task<Guid> Handle(CreateUserCommand request, CancellationToken ct)
    {
        var user = new User
        {
            Id = Guid.NewGuid(),
            Name = request.Name,
            Email = request.Email
        };

        _context.Users.Add(user);
        await _context.SaveChangesAsync(ct);
        return user.Id;
    }
}
```

---

### 6.3 `CreateUserCommandValidator.cs` (using FluentValidation)

```csharp
public class CreateUserCommandValidator : AbstractValidator<CreateUserCommand>
{
    public CreateUserCommandValidator()
    {
        RuleFor(x => x.Name).NotEmpty();
        RuleFor(x => x.Email).EmailAddress().NotEmpty();
    }
}
```

---

### 6.4 `UsersController.cs`

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController : ControllerBase
{
    private readonly ISender _mediator;

    public UsersController(ISender mediator)
        => _mediator = mediator;

    [HttpPost]
    public async Task<IActionResult> Create(CreateUserCommand command)
    {
        var userId = await _mediator.Send(command);
        return CreatedAtAction(nameof(GetById), new { id = userId }, null);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetById(Guid id)
    {
        var user = await _mediator.Send(new GetUserByIdQuery(id));
        return Ok(user);
    }
}
```

---

### 6.5 Register Everything in DI Container (`Program.cs`)

```csharp
builder.Services.AddMediatR(cfg => cfg.RegisterServicesFromAssemblyContaining<CreateUserHandler>());
builder.Services.AddValidatorsFromAssemblyContaining<CreateUserCommandValidator>();
builder.Services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
```

---

# ğŸ§  Summary of Best Practices

|Best Practice|Description|
|---|---|
|âœ… Use `record` types for commands/queries|Immutable and value-based|
|âœ… Separate `Application`, `Domain`, `Infrastructure`, and `API`|Clean Architecture|
|âœ… Add `ValidationBehavior` and other pipelines|Centralize cross-cutting concerns|
|âœ… Keep `Handlers` thin|Only handle the use case logic|
|âœ… Avoid injecting `DbContext` in Controller|Inject it in handler via abstraction (`IAppDbContext`)|
|âœ… Prefer `ISender` over `IMediator`|Narrower contract if you only need `Send`|
|âœ… Use FluentValidation for validating requests|Cleaner and testable|
