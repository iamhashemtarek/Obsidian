**CQRS** stands for **Command Query Responsibility Segregation**. It is a software architectural pattern that involves separating the **read** (query) and **write** (command) operations of a system into two different parts.

Here's a breakdown of the key concepts regarding CQRS from the sources:

- **Core Principle:** The pattern separates the flows for writing data from the flows for reading data. This separation is based on the **Command and Query Separation Principle**, which states that every method should either be a command that acts or a query that returns data, but not both. Queries should not change the state of the system (no side effects).
- **Commands vs. Queries:**
    - **Commands** are operations that change the state of the system or update the data. Examples include creating, updating, or deleting records. While the original principle suggested commands shouldn't return a value, in practice, it's often acceptable to return an ID or status from a command.
    - **Queries** are operations that only retrieve data and do not change the state of the system. Examples include getting a single record or listing multiple records.
- **Contrast with Traditional CRUD:** Traditional architectural patterns often use the same data model or DTO for both querying and writing to a data source. While this works for basic CRUD, it becomes limiting with more complex requirements and evolved applications. For instance, different properties might be needed for updating versus reading, or complex queries might force returning the entire entity.
- **Implementation:** CQRS can be implemented on a **logical level** within a single application and database, or it can involve physically splitting the data store. MediatR is a popular library that facilitates implementing the CQRS pattern in .NET applications. When used with MediatR, commands and queries are typically defined as request objects, and their processing logic is handled by separate handler classes.

In summary, CQRS is an architectural pattern that enhances ASP.NET Core application design by promoting a clear **separation between read and write operations**. This separation fundamentally improves **scalability** by allowing independent optimization and scaling of each side, and also improves design by simplifying data models and code organization.